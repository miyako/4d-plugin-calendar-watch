/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Calendar Watch
 #	author : miyako
 #	2016/06/27
 #
 # --------------------------------------------------------------------------------*/

#include "4DPluginAPI.h"
#include "4DPlugin.h"

namespace CalendarWatch
{
	
	class UserInfo
	{
		private:

			notification_t _notification;
			CUTF8String _uid;
			method_id_t _method;

		public:
		
			UserInfo(notification_t notification, NSString *event_uid, method_id_t method);
		
			void get(notification_t *notification, CUTF16String &event, method_id_t *method);
		
			~UserInfo();
	};

	UserInfo::UserInfo(notification_t notification, NSString *event_uid, method_id_t method)
	{
		this->_notification = notification;
		if(event_uid)
		{
			this->_uid = CUTF8String((const uint8_t *)[event_uid UTF8String]);
		}
		this->_method = method;
	}
	
	void UserInfo::get(notification_t *notification, CUTF16String &event, method_id_t *method)
	{
		*notification = this->_notification;
		
		*method = this->_method;
		
		C_TEXT t;
		t.setUTF8String(&this->_uid);
		t.copyUTF16String(&event);
	}

	UserInfo::~UserInfo()
	{

	}

	const process_stack_size_t stachSize = 0;
	const process_name_t processName = (PA_Unichar *)"$\0C\0A\0L\0E\0N\0D\0A\0R\0_\0W\0A\0T\0C\0H\0\0\0";
	
	std::map<CUTF8String, method_id_t> paths;
	std::vector<UserInfo> notifications;
	
	FSEventStreamRef eventStream = 0;
	NSTimeInterval latency = 1.0;
	process_number_t monitorProcessId = 0;
	bool processShouldTerminate = false;
	
	method_id_t getMethodId(NSString *path_ns)
	{
		@autoreleasepool
		{
			NSString *monitorPath_ns = [path_ns stringByDeletingLastPathComponent];
			CUTF8String monitorPath = CUTF8String((const uint8_t *)[monitorPath_ns UTF8String]);
			monitorPath += (const uint8_t *)"/";
			//global variables: CalendarWatch::paths
			NSLock *l = [[NSLock alloc]init];
			if ([l tryLock])
			{
				auto i = paths.find(monitorPath);
				if (i != paths.end())
				{
					return i->second;
				}
				[l unlock];
			}
			[l release];
		}
		return 0;
	}
	
	void gotEvent(FSEventStreamRef stream,
								void *callbackInfo,
								size_t numEvents,
								void *eventPaths,
								const FSEventStreamEventFlags eventFlags[],
								const FSEventStreamEventId eventIds[]
								)
	{
		//global variables: CalendarWatch::notifications
		NSLock *l = [[NSLock alloc]init];
		if ([l tryLock])
		{
			@autoreleasepool
			{
				NSArray *paths_ns = (NSArray *)eventPaths;
				NSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@"([:HexDigit:]{8}-[:HexDigit:]{4}-[:HexDigit:]{4}-[:HexDigit:]{4}-[:HexDigit:]{12})\\.ics$"
																																							 options:NSRegularExpressionCaseInsensitive
																																								 error:nil];
				if(regex)
				{
					for(NSUInteger i = 0; i < numEvents; ++i)
					{
						NSString *path_ns = [paths_ns objectAtIndex:i];
						
						NSArray *matches = [regex matchesInString:path_ns
																							options:0
																								range:NSMakeRange(0, [path_ns length])];
						
						for (NSTextCheckingResult *match in matches)
						{
							NSString *event_uid = [path_ns substringWithRange:[match rangeAtIndex:1]];
							FSEventStreamEventFlags flags = eventFlags[i];
							method_id_t methodId = getMethodId(path_ns);
							NSLog(@"flags:%d", (unsigned int)flags);
							if(methodId)
							{
								if((flags & kFSEventStreamEventFlagItemRemoved) == kFSEventStreamEventFlagItemRemoved)
								{
									NSLog(@"removed calendar item:\t%@", event_uid);
									UserInfo userInfo(notification_delete, event_uid, methodId);
									notifications.push_back(userInfo);
								}
								else if((flags & kFSEventStreamEventFlagItemCreated) == kFSEventStreamEventFlagItemCreated)
								{
									NSLog(@"created calendar item:\t%@", event_uid);
									UserInfo userInfo(notification_create, event_uid, methodId);
									notifications.push_back(userInfo);
								}
								else
								{
									NSLog(@"modified calendar item:\t%@", event_uid);
									UserInfo userInfo(notification_update, event_uid, methodId);
									notifications.push_back(userInfo);
								}
							}
						}
					}
				}
			}//@autoreleasepool
			listenerLoopExecute();
			[l unlock];
		}
		[l release];
	}
	
	void endMonitor()
	{
		//global variables: CalendarWatch::eventStream
		NSLock *l = [[NSLock alloc]init];
		if ([l tryLock])
		{
			if(eventStream)
			{
				FSEventStreamStop(eventStream);
				FSEventStreamUnscheduleFromRunLoop (eventStream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
				FSEventStreamInvalidate(eventStream);
				FSEventStreamRelease(eventStream);
				eventStream = 0;
				NSLog(@"stop monitoring paths");
			}
			[l unlock];
		}
		[l release];
	}
	
	void startMonitor()
	{
		FSEventStreamContext context = {0, NULL, NULL, NULL, NULL};
		
		NSMutableArray *paths_ns = [[NSMutableArray alloc]init];
		//global variables: CalendarWatch::paths
		NSLock *l = [[NSLock alloc]init];
		if ([l tryLock])
		{
			for(std::map<CUTF8String, method_id_t>::iterator it = CalendarWatch::paths.begin(); it != CalendarWatch::paths.end(); it++)
			{
				CUTF8String path = it->first;
				NSString *path_ns = [[NSString alloc]initWithUTF8String:(const char *)path.c_str()];
				if(path_ns)
				{
					[paths_ns addObject:path_ns];
					[path_ns release];
				}
			}
			[l unlock];
		}
		
		endMonitor();
		
		listenerLoopStart();
		
		if([paths_ns count])
		{
			if ([l tryLock])
			{
				eventStream = FSEventStreamCreate(NULL,
																					(FSEventStreamCallback)gotEvent,
																					&context,
																					(CFArrayRef)paths_ns,
																					kFSEventStreamEventIdSinceNow,
																					(CFAbsoluteTime)latency,
																					kFSEventStreamCreateFlagUseCFTypes
																					| kFSEventStreamCreateFlagFileEvents
																					| kFSEventStreamCreateFlagNoDefer
																					| kFSEventStreamCreateFlagIgnoreSelf
																					);
				NSLog(@"start monitoring paths:%@", [paths_ns description]);
				FSEventStreamScheduleWithRunLoop(eventStream, CFRunLoopGetCurrent(), kCFRunLoopDefaultMode);
				FSEventStreamStart(eventStream);
				
				[l unlock];
			}
			[l release];
			
		}
		[paths_ns release];
	}
	
	bool isInWatch(CUTF8String &path)
	{
		NSLock *l = [[NSLock alloc]init];
		if ([l tryLock])
		{
			auto i = paths.find(path);
			return (i != paths.end());
			[l unlock];
		}
		[l release];
		
		return false;
	}
	
	void addToWatch(CUTF8String &path, method_id_t methodId)
	{
		if (!isInWatch(path))
		{
			NSLock *l = [[NSLock alloc]init];
			if ([l tryLock])
			{
				paths.insert(std::map<CUTF8String, method_id_t>::value_type(path, methodId));
				PA_RunInMainProcess((PA_RunInMainProcessProcPtr)startMonitor, NULL);
				[l unlock];
			}
			[l release];
		}
	}
	
	void removeFromWatch(CUTF8String &path)
	{
		NSLock *l = [[NSLock alloc]init];
		if ([l tryLock])
		{
			paths.erase(path);
			PA_RunInMainProcess((PA_RunInMainProcessProcPtr)startMonitor, NULL);
			if(!paths.size())
			{
				listenerLoopFinish();
			}
						[l unlock];
		}
		[l release];
	}

	void removeAllFromWatch()
	{
		NSLock *l = [[NSLock alloc]init];
		if ([l tryLock])
		{
			paths.clear();
			PA_RunInMainProcess((PA_RunInMainProcessProcPtr)endMonitor, NULL);
			listenerLoopFinish();
			[l unlock];
		}
		[l release];
	}
	
}

#pragma mark -

bool isProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}

void onCloseProcess()
{
	if(isProcessOnExit())
	{
		CalendarWatch::removeAllFromWatch();
	}
}

void onStartup()
{
	
}

#pragma mark -

void generateUuid(C_TEXT &returnValue)
{
#if __MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
	returnValue.setUTF16String([[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#else
	CFUUIDRef uuid = CFUUIDCreate(kCFAllocatorDefault);
	NSString *uuid_str = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuid);
	returnValue.setUTF16String([uuid_str stringByReplacingOccurrencesOfString:@"-" withString:@""]);
#endif
}

void listenerLoop()
{
	CalendarWatch::monitorProcessId = PA_GetCurrentProcessNumber();
	NSLog(@"%@", @"listenerLoop:start");

	NSLock *l = [[NSLock alloc]init];
	
	while((!CalendarWatch::processShouldTerminate) && !PA_IsProcessDying())
	{
		PA_FreezeProcess(PA_GetCurrentProcessNumber());
		PA_YieldAbsolute();
		
		//global variables: CalendarWatch::notifications,processShouldTerminate
		if ([l tryLock])
		{
		if(!CalendarWatch::processShouldTerminate)
		{
			if(CalendarWatch::notifications.size())
			{
				C_TEXT processName;
				generateUuid(processName);
				PA_NewProcess((void *)listenerLoopExecuteMethod,
											CalendarWatch::stachSize,
											(PA_Unichar *)processName.getUTF16StringPtr());
			}
		}
			[l unlock];
		}
	}//while(!CalendarWatch::processShouldTerminate)
	CalendarWatch::monitorProcessId = 0;
	
	PA_KillProcess();
	NSLog(@"%@", @"listenerLoop:end");
	[l release];
}

void listenerLoopStart()
{
	//global variables: CalendarWatch::monitorProcessId,processShouldTerminate
	NSLock *l = [[NSLock alloc]init];
	if ([l tryLock])
	{
		if(!CalendarWatch::monitorProcessId)
		{
			CalendarWatch::processShouldTerminate = false;
			PA_NewProcess((void *)listenerLoop,
										CalendarWatch::stachSize,
										CalendarWatch::processName);
		}
		[l unlock];
	}
	[l release];
}
 
void listenerLoopFinish()
{
	//global variables: CalendarWatch::monitorProcessId,processShouldTerminate
	NSLock *l = [[NSLock alloc]init];
	if ([l tryLock])
	{
		CalendarWatch::processShouldTerminate = true;
		PA_UnfreezeProcess(CalendarWatch::monitorProcessId);
		[l unlock];
	}
	[l release];
}

void listenerLoopExecute()
{
	//global variables: CalendarWatch::monitorProcessId,processShouldTerminate
	NSLock *l = [[NSLock alloc]init];
	if ([l tryLock])
	{
		CalendarWatch::processShouldTerminate = false;
		PA_UnfreezeProcess(CalendarWatch::monitorProcessId);
		[l unlock];
	}
	[l release];
}

void listenerLoopExecuteMethod()
{
	//global variables: CalendarWatch::notifications
	NSLock *l = [[NSLock alloc]init];
	if ([l tryLock])
	{
		if(CalendarWatch::notifications.size())
		{
			std::vector<CalendarWatch::UserInfo>::iterator it = CalendarWatch::notifications.begin();
			
			CalendarWatch::UserInfo userInfo = *it;
			
			notification_t notification;
			CUTF16String eventId;
			method_id_t methodId;
			
			userInfo.get(&notification, eventId, &methodId);
			
			PA_Variable	params[2];
			
			params[0] = PA_CreateVariable(eVK_Unistring);
			params[1] = PA_CreateVariable(eVK_Longint);
			
			PA_Unistring event = PA_CreateUnistring((PA_Unichar *)eventId.c_str());
			PA_SetStringVariable(&params[0], &event);
			PA_SetLongintVariable(&params[1], notification);
			
			CalendarWatch::notifications.erase(it);
			
			PA_ExecuteMethodByID(methodId, params, 2);
			
			PA_ClearVariable(&params[0]);
			PA_ClearVariable(&params[1]);
		}
		[l unlock];
	}
	[l release];
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			onStartup();
			break;
		case kCloseProcess :
			onCloseProcess();
			break;
// --- Calendars

		case 1 :
			Calendar_GET_LIST(pResult, pParams);
			break;

		case 2 :
			Calendar_ADD_TO_WATCH(pResult, pParams);
			break;

		case 3 :
			Calendar_REMOVE_FROM_WATCH(pResult, pParams);
			break;

	}
}

#pragma mark -

const char *sql_get_calendar_group_uid = "SELECT\n\
ZUID\n\
FROM ZNODE\n\
WHERE Z_PK ==\n\
(\n\
 SELECT ZGROUP\n\
 FROM  ZNODE\n\
 WHERE ZUID == ?\n\
 LIMIT 1\n\
);";

const char *sql_get_calendars = "SELECT\n\
ZUID, ZTITLE\n\
FROM ZNODE\n\
WHERE ZISTASKCONTAINER != 1\n\
AND ZGROUP != '';";

void sqlite3_get_calendar_group_uid(NSString *userCalendarPath,
																		CUTF8String &calendar_uid,
																		CUTF8String &group_uid)
{
	NSLock *l = [[NSLock alloc]init];
	if ([l tryLock])
	{
		sqlite3 *sqlite3_calendar = NULL;
		
		int err = sqlite3_open([userCalendarPath UTF8String], &sqlite3_calendar);
		
		if(err != SQLITE_OK)
		{
			NSLog(@"failed to open sqlite database at:%@", userCalendarPath);
		}else
		{
			sqlite3_stmt *sql = NULL;
			err = sqlite3_prepare_v2(sqlite3_calendar, sql_get_calendar_group_uid, 1024, &sql, NULL);
			if(err != SQLITE_OK)
			{
				NSLog(@"failed to prepare sqlite statement");
			}else
			{
				sqlite3_bind_text(sql, 1, (const char *)calendar_uid.c_str(), calendar_uid.length(), NULL);
				
				while(SQLITE_ROW == (err = sqlite3_step(sql)))
				{
					const unsigned char *_group_uid = sqlite3_column_text(sql, 0);
					if(_group_uid)
					{
						group_uid = CUTF8String(_group_uid, strlen((const char *)_group_uid));
					}
				}
				sqlite3_finalize(sql);
			}
			sqlite3_close(sqlite3_calendar);
		}
		[l unlock];
	}
	[l release];
}

void sqlite3_get_calendars(NSString *userCalendarPath,
													 ARRAY_TEXT &uids,
													 ARRAY_TEXT &titles)
{
	NSLock *l = [[NSLock alloc]init];
	if ([l tryLock])
	{
		sqlite3 *sqlite3_calendar = NULL;
		
		int err = sqlite3_open([userCalendarPath UTF8String], &sqlite3_calendar);
		
		if(err != SQLITE_OK)
		{
			NSLog(@"failed to open sqlite database at:%@", userCalendarPath);
		}else
		{
			sqlite3_stmt *sql = NULL;
			err = sqlite3_prepare_v2(sqlite3_calendar, sql_get_calendars, 1024, &sql, NULL);
			if(err != SQLITE_OK)
			{
				NSLog(@"failed to prepare sqlite statement");
			}else
			{
				while(SQLITE_ROW == (err = sqlite3_step(sql)))
				{
					const unsigned char *_calendar_uid = sqlite3_column_text(sql, 0);
					const unsigned char *_title = sqlite3_column_text(sql, 1);
					
					if(_calendar_uid)
					{
						if(_title)
						{
							uids.appendUTF8String(_calendar_uid, strlen((const char *)_calendar_uid));
							titles.appendUTF8String(_title, strlen((const char *)_title));
						}
						
					}
				}
				sqlite3_finalize(sql);
			}
			sqlite3_close(sqlite3_calendar);
		}
		[l unlock];
	}
	[l release];
}

#pragma mark -

void Calendar_GET_LIST(sLONG_PTR *pResult, PackagePtr pParams)
{
	ARRAY_TEXT out_uids;
	ARRAY_TEXT out_paths;
	ARRAY_TEXT out_titles;
	ARRAY_LONGINT out_types;
	ARRAY_LONGINT out_watchings;
	
	@autoreleasepool
	{
		NSString *userCalendarPath = [NSString stringWithFormat:@"%@/Calendars/",
																		[NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES)
																		 objectAtIndex:0]];
			
		out_uids.setSize(1);
		out_paths.setSize(1);
		out_titles.setSize(1);
		out_types.setSize(1);
		out_watchings.setSize(1);
		
		sqlite3_get_calendars([NSString stringWithFormat:@"%@Calendar Cache", userCalendarPath], out_uids, out_titles);
		
		NSUInteger size = out_uids.getSize();
		
		for(NSUInteger i = 0; i < size; ++i)
		{
			CUTF8String calendar_uid, group_uid;
			out_uids.copyUTF8StringAtIndex(&calendar_uid, i);
			
			sqlite3_get_calendar_group_uid([NSString stringWithFormat:@"%@Calendar Cache", userCalendarPath], calendar_uid, group_uid);
			
			NSFileManager *defaultManager = [[NSFileManager alloc]init];
			
			NSString *path_caldav = [NSString stringWithFormat:@"%@%s%s/%s%s", userCalendarPath, group_uid.c_str(), ".caldav", calendar_uid.c_str(), ".calendar"];
			NSString *path_exchange = [NSString stringWithFormat:@"%@%s%s/%s%s", userCalendarPath, group_uid.c_str(), ".exchange", calendar_uid.c_str(), ".calendar"];
			
			BOOL isDirectory;
			if(([defaultManager fileExistsAtPath:path_caldav isDirectory:&isDirectory]) && isDirectory)
			{
				out_types.appendIntValue(1);
				out_paths.appendUTF16String([NSString stringWithFormat:@"%@/Events/", path_caldav]);
				out_watchings.appendIntValue(CalendarWatch::isInWatch(calendar_uid));
			}
			else if(([defaultManager fileExistsAtPath:path_exchange isDirectory:&isDirectory]) && isDirectory)
			{
				out_types.appendIntValue(5);
				out_paths.appendUTF16String([NSString stringWithFormat:@"%@/Events/", path_exchange]);
				out_watchings.appendIntValue(CalendarWatch::isInWatch(calendar_uid));
			}
			[defaultManager release];
		}
	
	}//@autoreleasepool
	
	out_uids.toParamAtIndex(pParams, 1);
	out_paths.toParamAtIndex(pParams, 2);
	out_titles.toParamAtIndex(pParams, 3);
	out_types.toParamAtIndex(pParams, 4);
	out_watchings.toParamAtIndex(pParams, 5);
}

void Calendar_ADD_TO_WATCH(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;

	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	method_id_t methodId = PA_GetMethodID((PA_Unichar *)Param2.getUTF16StringPtr());
	
	if(methodId)
	{
		CUTF8String path;
		Param1.copyUTF8String(&path);
		
		CalendarWatch::addToWatch(path, methodId);
	}

}

void Calendar_REMOVE_FROM_WATCH(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;

	Param1.fromParamAtIndex(pParams, 1);

	CUTF8String path;
	Param1.copyUTF8String(&path);
	
	CalendarWatch::removeFromWatch(path);
}

